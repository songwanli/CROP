// Generated by CoffeeScript 1.10.0
var constants, crypto;

crypto = require('crypto');

constants = require('constants');

module.exports = {
  encrypt: function(alg, data, key, encode) {
    var blockCount, blockSize, buffer, ciph, cipher, i, j, ref, ret;
    if (encode == null) {
      encode = 'base64';
    }
    switch (alg) {
      case 'none':
        return data;
      case 'rsa':
        blockSize = 256;
        blockCount = data.length / blockSize;
        ret = new Buffer(0);
        for (i = j = 0, ref = blockCount; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          buffer = new Buffer(data.slice(blockSize * i, blockSize * (i + 1)));
          if (buffer.length < blockSize) {
            buffer = Buffer.concat([new Buffer(new Array(blockSize - buffer.length)), buffer]);
          }
          ret = Buffer.concat([
            ret, crypto.publicEncrypt({
              key: key,
              padding: constants.RSA_NO_PADDING
            }, buffer)
          ]);
        }
        return ret.toString(encode);
      default:
        cipher = crypto.createCipheriv(alg, new Buffer(key), new Buffer(0));
        ciph = cipher.update(data, 'utf8', encode);
        ciph += cipher.final(encode);
        return ciph;
    }
  },
  decrypt: function(alg, data, key, encode) {
    var blockCount, blockSize, buffer, deciph, decipher, i, j, ref, ret;
    if (encode == null) {
      encode = 'base64';
    }
    switch (alg) {
      case 'none':
        return data;
      case 'rsa':
        blockSize = 256;
        blockCount = data.length / blockSize;
        ret = '';
        data = new Buffer(data, encode);
        for (i = j = 0, ref = blockCount; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          buffer = data.slice(blockSize * i, blockSize * (i + 1));
          ret += crypto.privateDecrypt({
            key: key,
            padding: constants.RSA_NO_PADDING
          }, buffer);
        }
        return ret.replace(/\u0000/g, '');
      default:
        decipher = crypto.createDecipheriv(alg, new Buffer(key), new Buffer(0));
        deciph = decipher.update(data, encode, 'utf8');
        deciph += decipher.final('utf8');
        return deciph;
    }
  },
  hash: function(alg, data, encode) {
    var h;
    if (encode == null) {
      encode = 'base64';
    }
    switch (alg) {
      case 'none':
        return void 0;
      default:
        h = crypto.createHash(alg);
        h.update(data);
        return h.digest(encode);
    }
  },
  getRandom: function(size, encode) {
    if (size == null) {
      size = 16;
    }
    if (encode == null) {
      encode = 'hex';
    }
    return crypto.randomBytes(size).toString(encode).toUpperCase();
  }
};
